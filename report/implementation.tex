Since the system workload and available resources will continually change, applications running in a virtual environment will need the ability to analyze performance at run time.  Existing resource usage tools such as top, sar, and vmstat in Linux OS and perfmon in Windows require additional information from external sources of data.  A framework is needed so that existing tools and new tools can be developed to show the true perfomance and resource usage of a virtualized system.

\indent  In this section we will explore the missing data that is needed, and design some tools to collect and analyze the addtional data from the point of view of a running guest system. First, we define the new layers of abstraction in virtual environments.  Then we identify the virtual resources that are needed for a virtualized guest.  For measuring I/O performance in virtual guest, we describe the following methods needed to collect and analyze the additional data:
\begin {enumerate}
\item Identify the performance counters on a virtual guest machine.
\item A method to calculate the overhead and theoritical maximum throughput using an offline modeling technique.
\item A method to analyze performance of a guest machine which may be experiencing degredation from external interference.
\item Example tool that dynamically analyzes runtime interference from I/O contention at different layers.
\end{enumerate}

After building an example tool we can introduce \emph{disk pinning}, where separate physical disks are assigned to individual virtual servers under a constant load.  Much research has shown that core pinning can dramatically improve CPU bound applications.  This will show how that idea translates to I/O bound virtual systems.  Obviously, the benefits of virtualization decrease as physical resources are bound to virtual machines.  With that considered, there may be significant improvments for I/O bound systems, where CPU cores may be shared.  We can use our new data to analyze the change in interference.

% 1 Define the new layers of abstraction virtual environments.
\subsection{Abstraction Layers}
In order to find the root cause of a degraded application running in a virtual machine, we first need to identify the addtional layers that could cause interference. Without virtualization, the problem could be in the applicaiton, OS, or hardware.  In a virtual environment, the hypervisor or unrelated guest also needs to be considered as a cause of the problem (Table \ref{tab:layers}).  The hypervisor provides the virtual resources to the guest and controls access to the physical hardware.  Since the guest machine can only access the hardware through the hypervisor, it will have some performance overhead. An external guest machine may also cause interference by competing for resources with other running guest machines.  Interference can be caused by the hypervisor and external guest need to be considered when analyzing performance problems.

\begin{table}
\begin{tabular}{ l p{10cm} }
  Layer & Definition \\
  \hline
  Application & Includes all code and libraries running in user space. \\
  OS & Includes all kernel code and device drivers. \\
  \textbf{Extrenal Guest} & An external virtual system. \\
  \textbf{Hypervisor} & The hypervisor and VMM to manage the guest domains. \\
  Hardare & Physical hardware. \\
  \hline
\end{tabular}
\caption{New layers \emph{Hypervisor} and \emph{External Guest} for virtualizataion}
\label{tab:layers}
\end{table}

% 2 Identify resources which are difficult to measure usage.
\subsection{Resources}
In order to determine the real cause of the performance problem the next step is to identify the resource which is the most influential to the performance problem.  
The goal is to determine if the application is bound by Memory, I/O, or CPU (Table \ref{tab:resources}).  In other words, adding \emph{additional} either Memory, I/O, or CPU would improve application performance. \\
\indent In a virtual environment, the resources allocated to a guest machine are an abstraction of the physical resources available.  
Any information obtained through the guest machine will not show interference from any of the new virtualization layers.  
Therefore, an administrator using system tools like sar and vmstat will not be able to determine the true availability of the resource for the application.  
Additional information is needed from hypervisor about the physical resource so that the administrator, OS, or application can make better decisions about the availability of the resource. 

\begin{table}
  \begin{tabular}{ l p{10cm} }
    Resource & Definition \\
    \hline
    CPU & The virtual core allocated to the guest \\
    Memory & The virtual RAM allocated to the guest \\
    Disk I/O & The virtual block disk I/O system \\
    Net I/O & The virtual network I/O system \\
    \hline
Â  \end{tabular}
\caption{Virtual resources which may experience interference}
\label{tab:resources}
\end{table}

% 3 Identify the performance counters which can be used to measure I/O performance on a virtual guest machine.
\subsection{Performance Counters}
On a Linux OS many of the system administrator utilities used to identify resource usage comes from the /proc filesystem. 
For example the \emph{sar -d} command will show block device statistics such as transfers/sec, reads/sec, and writes/sec, as well as many other statistics.  
Similar GUI are available on Microsoft Windows OS through perfmon.exe and an API in the Windows Performance Toolkit \cite{winperf}. 
The hypervisor divides the physical resource into virtual resources for each guest.  
Additionally, each resource may be shared between multiple guests by overcommitting the resource.  
When a guest system views statistics about a resource, part of the information is missing from the guest application.  
Interference from the hypervisor and external guests need to be passed to the guest virtual machine about the true performance of the resource. 

\indent The Linux kernel tracks I/O statistics in \emph{diskstat} and virtual memory statistics in \emph{vmstat} (Table \ref{tab:iocounters}).  
These counters an help identify disk I/O contention issues and are used by adminstrative utilites sar and iostat \cite{iostats}.  
Similar counters can be used for other operating systems or resources. 
For modern operating systems it is important to collect both I/O and virtual memory information when analyzing I/O contention, since disk reads and writes are buffered and cached in memory for performance reasons. 

\indent For each resource available on a most operating systems, there are OS level statistics collected about those resources.  It is important to indentify the resources used, and methods of collecting resources.  
For our examples we use I/O statistics, but other statistics could be collected for CPU or memory usage.

\begin{table}
\begin{tabular}{ l l p{5cm} }
  Statistics & Description \\
  \hline
  /proc/diskstat & I/O statistics of block devices \\
  /proc/vmstat & Detailed virtual memory statistics\\
  \hline
\end{tabular}
\caption{Disk I/O performance counters on Linux.}
\label{tab:iocounters}
\end{table}


% 4 A method to calculate the overhead and theoritical maximum performance using an offline modeling technique.
\subsection{Virtualization Overhead}
For each virtual resource (Table \ref{tab:resources}) there is a performance cost to making that resource virtualized, instead of allowing the guest OS to have direct access to the hardware.  
Several researchers \cite{cherkasova, huber1} have called this cost the \emph{overhead}.  
Additionally they quantified the overhead for CPU and memory intensive applications for a given configuration.  Our experiments will calculate the overhead for Disk I/O using an offline modeling technique similar to previous research.

\indent Before a guest application is run in a virtualized environment, we need to calculate the \emph{overhead} in that environment.  This only needs to be done once per configuration.  In large scale datacenters and cloud systems, templates are created before virtual machines are used in production.  A template is a snapshot image of a virtual machine that has been built and tested to meet some need.  For example a Redhat 6.2 system with an Apache web server may need to be used on several machines.  A system could be built, tuned, and tested for that enviroment and then made into a template.  Future users can deploy a new virtual machine from that known state.  We are suggesting that the \emph{overhead} be calculated before being made into a template.  

\indent To calculate the virtualization overhead, create a single virtual machine with dedicated resources on isolated hardware.  There should not be any other virtual guest machines running.  Next we need to find a load that will stress each resource.  It may be possible to generate a load that will stress I/O, memory, and CPU, but it is best to stress them separately since other interference could mislead results.  Then place the load on the machine and begin monitoring the resource using the previously determined performance counters in BOTH the guest OS and hypervisor. Previous research calculated the overhead of virtualization between running on a physical server and running on a guest.  Our method dynamically calculates the overhead while running a single guest machine.

\indent For a given performance counter, we count the hypervisor \emph{count\textsubscript{H}} and the guest \emph{count\textsubscript{G}}.  We calculate the overhead from virtualization as:
\[ Overhead_V = \frac{count_H - count_G}{count_H} \]


% A method to analyze performance of a guest machine which may be experiencing degredation from external interference.
\subsection{Detecting I/O Interference}
In order to collect performance I/O metrics (such as reads/second and writes/second) with a complete view of the resource, we need a method to calculate how much of that resource is used by the external guests and the hypervisor overhead.  At each layer, data and statistics need to be collected to determine why the application may be degraded.
\indent When a tool runs in the userspace of guest machine to get resource usage, the guest OS should collect information about the usage of the resource from the hypervisor and external guests.  If the guest has previously collected the  \emph{overhead} and \emph{tmax}, then the guest virtual machine can determine if the resource is available and the problem is in the guest machine, or the resource is degraded from external interference.

\begin{enumerate}
	\item Guest tool requests OS statistics.
	\item Guest OS forwards request to hypervisor.
	\item Hypervisor forwards request to all guests.
	\item Each Guest responds with individual statistics.
	\item Hypervisor calculates a percentage of resource used.
	\item Hypervisor returns data to original requestor.
	\item Guest tool shows overhead and interference from external guests.
\end{enumerate}

As an example: the userspace tool \emph{iostat} reads disk performance counters in /proc/diskstats and will report transfers, bytes read, and bytes written per second.  If an application was experiencing I/O performance problems these would be counters an administrator or application developer may monitor.  These numbers may be misleading as to the root cause of the problem if external interference is causing the problem.  
\begin{figure}
\begin{Verbatim}
Device:  tps    kB_read/s    kB_wrtn/s
sda   577.20     41388.00    148073.00
virtual I/O interference 22.4%     
\end{Verbatim}
\label{fig:iostat}
\caption{\emph{iostat} with additional information from hypervisor calcuated interference}
\end{figure}

\subsection{Disk Pinning}
Disk pinning may be a solution for multiple I/O bound guest appliations running in a virtual system.  Several papers have demonstrated the effects of core pinning or \emph{core affinity} for CPU bound applications, which can reduce the load on the hypervisor and prevent cache contention.  Similarly, a multiple I/O bound guests may use a single disk excessivley causing interference and degreaded performance.  By increasing the number of physical spindles, multiple random disk seeks can occur concurrently.  By setting physical disks to specific virtual guests, we can reduce I/O interference from multiple guests.  For applications that are bound by virtual I/O resources, it may be better to share cores and separate physical disks for each virtual machine.  At some point assigning a dedicated physical resource to guest machines minimizes the benefits of virtualizaion.  It should be the task of the administrator to decide how the physical resources are used based on the need.
